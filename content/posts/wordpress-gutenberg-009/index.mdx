---
title: 'Wasne bloki w WordPress Gutenberg #009 - edytujemy nasz panel boczny! Wyb贸r kolor贸w i pole zakresu'
seoTitle: Edytujemy nasz panel boczny w Gutenbergu!
abstract: W tej czci serii o tworzeniu wasnych blok贸w w WordPress Gutenberg, zedytujemy panel boczny dodajc do niego 2 przydatne komponenty!
isPublished: true
topics:
  - WordPress
  - Wasne bloki w WordPress Gutenberg
date: 17.01.2022
isPopular: false
---

W ostatniej czci tej serii, zbudowalimy podwaliny pod funkcjonalne elementy naszego panelu bocznego. Dzi dodajmy do niego 2 komponenty, aby mie z niego prawdziwy po偶ytek!

A komponenty te, to wybierak kolor贸w, kt贸ry posu偶y do zmiany koloru ta oraz pole zakresu - ono z kolei pozwoli nam zmieni margines wewntrzny tworzonego przez nas spisu treci.

Oba te elementy zrealizujemy dziki wbudowanym ju偶 w Gutenberga komponentom. Lemy 

## Po pierwsze - kolorki!

Idealnym sposobem na pozwolenie osobie korzystajcej z naszego bloku edytowa to spisu treci, bdzie komponent o nazwie `<ColorPalette />`.

Pierwsza rzecz, kt贸r zrobimy, aby z niego skorzysta, to oczywicie zaimportowanie go na g贸rze pliczku z niestandardowym blokiem Gutenberga:

```jsx
import { ColorPalette } from '@wordpress/components';
```

Razem z reszt zaimportowanych element贸w, prezentowa si on bdzie w spos贸b nastpujcy:

```jsx
import { registerBlockType } from '@wordpress/blocks';
import { RichText, BlockControls, InspectorControls } from '@wordpress/block-editor';
import { Toolbar, ToolbarButton, Icon, PanelBody, ColorPalette } from '@wordpress/components';
import { registerFormatType, toggleFormat } from '@wordpress/rich-text';
import { useSelect } from '@wordpress/data';
```

A u偶yjemy go w ramach panelu bocznego, kt贸ry po ostatniej czci tej serii, wyglda nastpujco:

```jsx
<PanelBody title="Tytu pierwszej zakadki">
  <p>Tre pierwszej zakadki</p>
</PanelBody>
<PanelBody title="Tytu drugiej zakadki">
  <p>Tre drugiej zakadki</p>
</PanelBody>
```

Usumy drug zakadk, a pierwsz zamiemy na co takiego:

```jsx
<PanelBody title="Kolor ta">
  <ColorPalette
    colors={[
      { name: 'Niebieski', color: '#E3F2FD' },
      { name: 'Niebieski - przydymiony', color: '#ECEFF1' },
      { name: 'Czerwony', color: '#FFEBEE' },
    ]}
    value={backgroundColor}
    onChange={setBackgroundColor}
  />
</PanelBody>
```

Zaraz powiem Ci skd bierzemy zmienn `backgroundColor` oraz funkcj `setBackgroundColor()`. Tymczasem warto powiedzie, 偶e to wanie w ramach waciwoci `colors` wrzucam wszystkie predefiniowane kolory, a dodatkowo w ramach samego wybieraka bd w stanie zaaplikowa (jako administrator korzystajcy z naszego spisu treci) jakikolwiek kolor mi si 偶ywnie podoba, bo po zastosowaniu powy偶szego kodu, sam wybierak wyglda bdzie nastpujco:

![](./color-picker.jpg)

Jak wida, na dole mamy 2 przyciski - pierwszy pozwalajcy wybra dowolny kolor ponad zdefiniowane oraz drugi, kt贸ry umo偶liwia wyczyszczenie wybranego koloru (oczywicie ju偶 po tym, gdy jaki kolor zostanie przez nas wybrany). W razie potrzeby, same przyciski jestemy w stanie schowa za pomoc waciwoci `disableCustomColors` i `clearable`:

```jsx
<ColorPalette
  // ...
  disableCustomColors={false}
  clearable={false}
/>
```

Domylnie waciwoci te s ustawione na `true`.

Okej - zdefiniujmy `backgroundColor` u偶yty wczeniej w propsie `value`. A zrobimy to w ramach nowego atrybutu (kt贸ry p贸藕niej pobierzemy w metodzie `save()`).

```jsx
attributes: {
  // ...
  backgroundColor: {
    type: 'string',
  },
},
```

Warto to jeszcze pobra w ramach metody `edit()`, razem z innymi:

```jsx
edit({ attributes, setAttributes }) {
    const { title, list, backgroundColor } = attributes;

  	// ...
```

I zaaplikowa jego warto dla elementu otulajcego nasz spis treci, aby zmiany dokonane w ramach wybieraka, byy od razu widoczne w panelu:

```jsx
return (
  <>
    <InspectorControls>
      <PanelBody title="Kolor ta">
        <ColorPalette
          colors={[
            { name: 'Niebieski', color: '#E3F2FD' },
            { name: 'Niebieski - przydymiony', color: '#ECEFF1' },
            { name: 'Czerwony', color: '#FFEBEE' },
          ]}
          value={backgroundColor}
          onChange={setBackgroundColor}
        />
      </PanelBody>
    </InspectorControls>
    <div class="table-of-contents-block" style={{
      backgroundColor: backgroundColor,
    }}>

    // ...
```

I dodatkowo, stw贸rzmy funkcj `setBackgroundColor()`, dziki kt贸rej bdziemy mogli ten atrybut zmieni przy okazji zmiany koloru:

```jsx
function setBackgroundColor(newColor) {
  setAttributes({ backgroundColor: newColor });
}
```

Czy co Ci ona przypomina? Na pewno mo偶e przypomina Ci 2 funkcje zadeklarowane obok niej w poprzednich czciach kursu: `setTitle()` i `setListContent()` - wszystkie one po prostu ustawiaj warto jednego z trzech przygotowanych przez nas atrybut贸w.

> Jeli tworzysz spis treci r贸wno ze mn, to na tym etapie sprawd藕 dziaanie dodanego wybieraka kolor贸w - powinien on w peni dziaa, zmieniajc to naszego spisu treci w samym edytorze.
>
> Ale nie zmienia on w 偶aden spos贸b front-endu, co oznacza, 偶e musimy doda obsug tego koloru r贸wnie偶 w metodzie `save()`!

Na koniec, aby zastosowa zmiany na front-endzie, zedytuj metod `save()` w nastpujcy spos贸b:

```jsx
save({ attributes }) {
  const { title, list, backgroundColor } = attributes;

  return (
    <div class="table-of-contents-block" style={{
      backgroundColor: backgroundColor,
    }}>
      <RichText.Content tagName="h2" value={title} />
      <RichText.Content tagName="ol" value={list} />
    </div>
  );
},
```

Po tym co udao nam si ju偶 zrobi, ten kod powinien by dla Ciebie jasny. Jedyne co, to warto skr贸ci lekko zapis w propsie `style`, bo gdy w JavaScriptcie przypisujemy do pola zmienn o takiej samej nazwie co samo pole, to wystarczy, 偶e nazw t zapiszemy tylko jeden raz:

```jsx
save({ attributes }) {
  const { title, list, backgroundColor } = attributes;

  return (
    <div class="table-of-contents-block" style={{
      backgroundColor,
    }}>
      <RichText.Content tagName="h2" value={title} />
      <RichText.Content tagName="ol" value={list} />
    </div>
  );
},
```

Tak samo oczywicie warto zrobi w funkcji `edit()`:

```jsx
return (
  <>
    <InspectorControls>
      <PanelBody title="Kolor ta">
        <ColorPalette
          colors={[
            { name: 'Niebieski', color: '#E3F2FD' },
            { name: 'Niebieski - przydymiony', color: '#ECEFF1' },
            { name: 'Czerwony', color: '#FFEBEE' },
          ]}
          value={backgroundColor}
          onChange={setBackgroundColor}
        />
      </PanelBody>
    </InspectorControls>
    <div class="table-of-contents-block" style={{
      backgroundColor,
    }}>

    // ...
```

I tak oto, wyb贸r ta naszego spisu treci dziaa! Mo偶emy teraz przej do analogicznej funkcji - pola, kt贸re przejmie kontrol nad marginesem wewntrznym owego spisu treci.

## To teraz dodajmy mo偶liwo zmiany paddingu!

W tym przypadku przez cao przejd troch szybciej, bo spora ilo krok贸w, po prostu si powt贸rzy.

Potrzebujemy kolejnego komponentu. Tym razem, cho idealnym kandydatem do tego zadania, byby [`<DimensionControl />`](https://github.com/WordPress/gutenberg/tree/trunk/packages/components/src/dimension-control), to ja skorzystam z `<RangeControl />` z racji, 偶e w momencie gdy pisz te sowa, `<DimensionControl />` cay czas jest w fazie eksperymentalnej i nie chc, aby zapisy na jego temat za chwilk przestay by aktualne.

Wobec tego, dodajemy `<RangeControl />` do reszty import贸w:

```jsx
import { registerBlockType } from '@wordpress/blocks';
import { RichText, BlockControls, InspectorControls } from '@wordpress/block-editor';
import {
  Toolbar,
  ToolbarButton,
  Icon,
  PanelBody,
  ColorPalette,
  RangeControl,
} from '@wordpress/components';
import { registerFormatType, toggleFormat } from '@wordpress/rich-text';
import { useSelect } from '@wordpress/data';
```

I u偶yjmy go obok wybieraka kolor贸w:

```jsx
<InspectorControls>
  // ...
  <PanelBody title="Odstp wewntrzny">
    <RangeControl value={padding} onChange={setPadding} initialPosition={0} />
  </PanelBody>
</InspectorControls>
```

Dodajemy atrybut `padding`:

```jsx
attributes: {
  // ...
  padding: {
    type: 'number',
  },
},
```

Pobierzmy go w metodach `edit()` i `save()`:

```jsx
const { title, list, backgroundColor, padding } = attributes;
```

Dodajmy do styl贸w kontenera, trzymajcego nasz spis treci:

```jsx
<div
  class="table-of-contents-block"
  style={{
    backgroundColor,
    padding,
  }}
>
  // ...
</div>
```

I stw贸rzmy funkcj go aktualizujc:

```jsx
function setPadding(newPadding) {
  setAttributes({ padding: newPadding });
}
```

I mamy to コ

Od tej chwili jestemy w stanie zmienia `padding` naszego spisu treci. Oczywicie jeli Ty w swoim niestandardowym bloku Gutenberga chcesz pozwoli na definiowanie odstp贸w z ka偶dej strony z osobna, to mo偶esz utworzy 2 lub 4 osobne pola, kt贸re administratora danej strony na WordPressie bdzie w stanie zmienia!

## I kilka s贸w na koniec!

Od teraz, w ramach stworzonego spisu treci, w bardzo przyjemny spos贸b jestemy w stanie zmieni kolor ta oraz odstp wewntrzny caej treci naszego bloku:

![](./rezultat.jpg)

T czci chciaem pokaza Ci, w jak prosty spos贸b mo偶emy dostosowa mo偶liwoci edycji tworzonych przez nas blok贸w!

W poczeniu z na przykad [blokami zagnie偶d偶onymi](https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/nested-blocks-inner-blocks/), daje nam to ogromne mo偶liwoci i to za ma cen, patrzc na to, jak wiele rzeczy mo偶emy stworzy na bazie istniejcych komponent贸w, wbudowanych w Gutenberga.

I co na koniec chce Ci powiedzie, to to, 偶e dzi wyjtkowo pozostawi Ci bez zadania domowego  Nastpna cz tego kursu, bdzie prawdopodobnie ostatni - poka偶 Ci w niej, czego mo偶esz si uczy, aby wykorzysta zdobyte w ramach tej serii solidne podstawy, a dziki zdobytej wiedzy tworzy ju偶 bardziej skomplikowane bloki i komponenty.

Tak偶e do zobaczenia wanie w niej - 10 czci serii o tworzeniu wasnych blok贸w Gutenberga!

PS. Kod z tej czci, oczywicie znajdziesz [na moim GitHubie](https://github.com/robert-orlinski/gutenberg-blocks-course-files/tree/009) 

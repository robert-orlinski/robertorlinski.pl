---
title: Szybsze renderowanie stron internetowych, dziÄ™ki wÅ‚aÅ›ciwoÅ›ciom contain i content-visibility
seoTitle: Szybkie strony dziÄ™ki contain i content-visibility w CSS
abstract: WÅ‚aÅ›ciwoÅ›ci contain oraz content-visibility, pozwalajÄ… na znacznie szybsze renderowanie stron internetowych. To o nich jest ten artykuÅ‚ ğŸ’¥
isPublished: true
topics:
  - Front-end
date: 22.02.2021
isPopular: true
menuOrder: -2
---

W tym artykule powiem Ci o trzech wÅ‚aÅ›ciwoÅ›ciach CSSa, ktÃ³re poprawiÄ… wydajnoÅ›Ä‡ i uÅ¼ytecznoÅ›Ä‡ Twoich stron. PozwolÄ… Ci przejÄ…Ä‡ kontrolÄ™ nad tym jak i kiedy renderujÄ… siÄ™ style poszczegÃ³lnych elementÃ³w.

A wÅ‚aÅ›ciwoÅ›ci te, to:

- `contain`
- `content-visibility`
- `contain-intrinsic-size`

Na poczÄ…tku przedstawiÄ™ Ci, jak przeglÄ…darki stylujÄ… strony internetowe, a pÃ³Åºniej jakie zastosowanie w tym procesie, majÄ… wymienione powyÅ¼ej wÅ‚aÅ›ciwoÅ›ci.

Okej, to zacznijmy od poczÄ…tku.

## Jak przeglÄ…darki Å‚adujÄ… i renderujÄ… strony internetowe?

AbyÅ›my mogli zobaczyÄ‡ zdefiniowany przez nas wyglÄ…d serwisu, musi on przejÅ›Ä‡ przez 4 etapy renderowania:

1. **Parse** - krok, podczas ktÃ³rego przeglÄ…darka tworzy strukturÄ™ strony dla HTMLa, a pÃ³Åºniej dla CSSa. DziÄ™ki temu wie, z czego skÅ‚ada siÄ™ nasza strona i jakie selektory CSSa dotyczÄ… jakich elementÃ³w.
2. **Layout** - krok, w ktÃ³rym przeglÄ…darka ustala, jakie wymiary bÄ™dÄ… miaÅ‚y nasze elementy. Bierze pod uwagÄ™ zdefiniowane przez nas style, jak i oblicza rozmiary elementÃ³w niezdefiniowanych na sztywno (tych, ktÃ³rych rozmiary zaleÅ¼Ä… od innych elementÃ³w, najczÄ™Å›ciej rodzicÃ³w).
3. **Paint** - w tym kroku przeglÄ…darka wypeÅ‚nia piksel po pikselu caÅ‚y widok, wg tego co udaÅ‚o jej siÄ™ obliczyÄ‡ wczeÅ›niej.
4. **Composite** - wisienka na torcie, w ktÃ³rej ustalane sÄ… warstwy konkretnego serwisu. To tutaj dopiero przeglÄ…darka decyduje, Å¼e na przykÅ‚ad nawigacja na Twojej stronie bÄ™dzie przykrywaÄ‡ baner pod niÄ….

I co dla nas w tej chwili szczegÃ³lnie waÅ¼ne - kaÅ¼dy z tych krokÃ³w kaÅ¼e nam czekaÄ‡ na swoje wykonanie. Dopiero po zrealizowaniu siÄ™ wszystkich moÅ¼emy zobaczyÄ‡ naszÄ… stronÄ™ w peÅ‚nej okazaÅ‚oÅ›ci.

## Okej, to jakÄ… rolÄ™ w tym wszystkim majÄ… wÅ‚aÅ›ciwoÅ›ci z poczÄ…tku?

> W skrÃ³cie, pozwalajÄ… nam wybieraÄ‡ **ktÃ³re z etapÃ³w renderowania** (lub pojedynczych zadaÅ„ realizowanych w tych etapach) **sÄ… pomijane**.
>
> Pomijane w ogÃ³le (wÅ‚aÅ›ciwoÅ›Ä‡ `contain`) lub wtedy, gdy nie widzimy na ekranie danego elementu (wÅ‚aÅ›ciwoÅ›Ä‡ `content-visibility`).

I tak naprawdÄ™, wÅ‚aÅ›ciwoÅ›Ä‡ `contain`, jest matkÄ… tego o czym tu rozmawiamy.

Bez niej nie byÅ‚oby `content-visibility`, bo ta druga wÅ‚aÅ›ciwoÅ›Ä‡ w gÅ‚Ã³wnej swojej roli to tak naprawdÄ™ `contain` z kilkoma wartoÅ›ciami, dziaÅ‚ajÄ…cÄ… tylko wtedy, gdy elementu nie widaÄ‡ na ekranie. I tak samo, bez niej niepotrzebna byÅ‚aby wÅ‚aÅ›ciwoÅ›Ä‡ `contain-intrinsic-size`.

Wiem, Å¼e na ten moment moÅ¼e wydawaÄ‡ siÄ™ to zagmatwane, ale do koÅ„ca artykuÅ‚u gwarantujÄ™ Ci, Å¼e wszystko siÄ™ rozjaÅ›ni âœ¨

### WÅ‚aÅ›ciwoÅ›Ä‡ `contain` i jej moÅ¼liwoÅ›ci

MoÅ¼e ona przyjÄ…Ä‡ takie oto wartoÅ›ci:

```css
contain: size;
contain: layout;
contain: paint;
contain: style;

contain: content;
contain: strict;
contain: none;
```

I moÅ¼e przyjmowaÄ‡ teÅ¼ kilka wÅ‚aÅ›ciwoÅ›ci jednoczeÅ›nie, na przykÅ‚ad:

```css
contain: size paint;
```

Powiedzmy jakÄ… dokÅ‚adnie robotÄ™, wszystkie te wartoÅ›ci wykonujÄ….

#### `Contain: size`

Za pomocÄ… tej wartoÅ›ci, moÅ¼emy powiedzieÄ‡ **przeglÄ…darce**, Å¼e **nie musi zwracaÄ‡ uwagi na wielkoÅ›Ä‡ dzieci konkretnego elementu.** DziÄ™ki temu, caÅ‚a kalkulacja szerokoÅ›ci i wysokoÅ›ci rodzica, jest pomijana.

Natomiast to **wymaga od nas, abyÅ›my zdefiniowali te rozmiary na sztywno** - w koÅ„cu gdy przeglÄ…darka pominie ich ustalanie wg wielkoÅ›ci potomkÃ³w (a jednoczeÅ›nie sami tego nie zrobimy), to zostaniemy z elementem o wielkoÅ›ci 0x0 px.

MoÅ¼esz zerknÄ…Ä‡ na te 2 figury:

import CodePenIframe from 'CodePenIframe';

<CodePenIframe id="mdOMBQz" title="(CSS) contain: size" />

Po lewej widzisz domyÅ›lne zachowanie, po prawej z kolei wersjÄ™ z wÅ‚aÅ›ciwoÅ›ciÄ… `contain`, bez ustalonej wysokoÅ›ci.

#### `Contain: layout`

WartoÅ›Ä‡ `layout` mÃ³wi przeglÄ…darce, Å¼e **potomkowie konkretnego elementu nie majÄ… wpÅ‚ywu na inne elementy na stronie i w drugÄ… stronÄ™** - elementy strony nie majÄ… wpÅ‚ywu na potomkÃ³w elementu, do ktÃ³rego dodamy wÅ‚aÅ›ciwoÅ›Ä‡ `contain`.

Dodatkowo, gdy do elementu dodamy `contain: layout`, to otrzyma on wÅ‚asny kontekst warstw, podobnie jak to dzieje siÄ™ w elementach, do ktÃ³rych dodamy `position: relative`. Przez to wszystkie uÅ¼ycia `z-index`, `top`, `left` itp. bÄ™dÄ… wydarzaÄ‡ siÄ™ wzglÄ™dem tego elementu.

Natomiast co ciekawe, element, do ktÃ³rego dodamy `contain: layout`, moÅ¼e dalej mieÄ‡ wpÅ‚yw na inne czÄ™Å›ci strony. Wszystko przez to, Å¼e jego potomkowie nie mogÄ… mieÄ‡ wpÅ‚ywu na inne czÄ™Å›ci strony, ale majÄ… na niego. Na przykÅ‚ad, sÄ… w stanie zmieniÄ‡ jego wielkoÅ›Ä‡, a gdy on - element nadrzÄ™dny, do ktÃ³rego dodaliÅ›my wÅ‚aÅ›ciwoÅ›Ä‡ `contain` - zmieni swojÄ… wielkoÅ›Ä‡, to wpÅ‚ynie na uÅ‚oÅ¼enie elementÃ³w wokÃ³Å‚ niego.

#### `Contain: paint`

Tu z kolei mamy do czynienia z `overflow: hidden` na sterydach.

`Contain: paint`, pozwala nam obciÄ…Ä‡ wszystkich potomkÃ³w danego elementu, w taki sposÃ³b, aby te nie byÅ‚y renderowane i tym samym pokazywane, gdy wychodzÄ… poza jego przestrzeÅ„. Na razie sprawia wraÅ¼enie dokÅ‚adnie takiego samego, co `overflow: hidden`.

Ale wÅ‚aÅ›nie, tu dochodzÄ… sterydy (ale bardzo zdrowe):

- `Contain: paint` pomija renderowanie swoich dzieci, gdy nie ma ich w viewporcie (zakÅ‚ada, Å¼e jeÅ›li nic nie moÅ¼e wychodziÄ‡ poza element, ktÃ³rego nie widzi uÅ¼ytkownik, to nie ma potrzeby generowania jego podelementÃ³w, bo uÅ¼ytkownik i tak ich nie zobaczy).
- I podobnie, jak wartoÅ›Ä‡ `layout`, `paint` tworzy nowy kontekst warstw, wiÄ™c w jego obrÄ™bie moÅ¼emy uÅ¼ywaÄ‡ np. wÅ‚aÅ›ciwoÅ›ci top, left itp.

#### `Contain: style`

Ostania wÅ‚aÅ›ciwoÅ›Ä‡ (z tych gÅ‚Ã³wnych). Nie bez powodu, bo jest tak naprawdÄ™ najmniej znaczÄ…ca z naszej czwÃ³rki. A dodatkowo [istnieje ryzyko, Å¼e wypadnie ze specyfikacji](https://drafts.csswg.org/css-contain-2/#style-containment).

Ogranicza ona kontekst wÅ‚aÅ›ciwoÅ›ci:

- `counter-increment`
- `counter-set`

...oraz wartoÅ›ci:

- `open-quote`
- `close-quote`
- `no-open-quote`
- `no-close-quote`

...dla wartoÅ›ci `content`.

DziÄ™ki temu, gdy uÅ¼yjemy czegoÅ› z wypisanych rzeczy, zastosowanie to bÄ™dzie miaÅ‚o wpÅ‚yw tylko na element, na ktÃ³rym uÅ¼yliÅ›my `contain: style` oraz jego potomkÃ³w.

Ograniczamy tym samym potrzebÄ™ sprawdzania, czy w innym obrÄ™bie strony nie istnieje coÅ›, co te wÅ‚aÅ›ciwoÅ›ci modyfikuje.

#### `Contain: content`

Tu jest juÅ¼ bardzo prosto. SÄ… to wartoÅ›ci `layout` oraz `paint`, wyraÅ¼one jednym sÅ‚owem.

#### `Contain: strict`

Podobnie jak w poprzednim akapicie, ale tym razem do `layout` oraz `paint`, dochodzi jeszcze `size`.

#### `Contain: none`

Tego chyba nie muszÄ™ tÅ‚umaczyÄ‡ :)

### To teraz `content-visibility`

A za niÄ… rÃ³wnieÅ¼ `contain-intrinsic-size`, ale do tej drugiej wrÃ³cimy za chwilkÄ™. `Content-visiblity` oferuje 3 moÅ¼liwe wartoÅ›ci:

```
content-visiblity: none;
content-visiblity: auto;
content-visiblity: hidden;
```

Powiedzmy sobie o dwÃ³ch ostatnich.

#### `Content-visiblity: auto`

Tutaj dzieje siÄ™ caÅ‚a zabawa. OtÃ³Å¼, `content-visibility: auto`, daje konkretnemu elementowi:

```css
contain: layout style paint size;
```

Czyli tak naprawdÄ™ wszystko, co oferuje nam omÃ³wiona wczeÅ›niej wÅ‚aÅ›ciwoÅ›Ä‡ `contain`. A caÅ‚oÅ›Ä‡ aplikuje siÄ™ wtedy, gdy element jest poza viewportem (czyli uÅ¼ytkownik go nie widzi).

A dziÄ™ki temu, po prostu siÄ™ nie renderuje, przez co strona Å‚aduje siÄ™ znacznie, znacznie szybciej. Najpierw skupia siÄ™ na tym, co widzi uÅ¼ytkownik i dopiero gdy to jest wygenerowane w peÅ‚ni, przechodzi do dalszych czÄ™Å›ci strony.

> Chyba Å¼e zjedziemy w dÃ³Å‚ na danej witrynie - wtedy priorytet siÄ™ zmienia, bo inne elementy stajÄ… siÄ™ tym, co widzimy na ekranie.

#### `Content-visibility: hidden`

Tu jest znacznie proÅ›ciej, bo za pomocÄ… tej wÅ‚aÅ›ciwoÅ›ci po prostu chowamy konkretny element, bardzo podobnie jak robimy to w przypadku `display: none` oraz `visibility: hidden`. BiorÄ…c po troszku z zachowania obu.

Bo element schowany za pomocÄ… `content-visibility: hidden`, nie zniszczy swojego stanu renderowania (podobnie jak dzieje siÄ™ to w przypadku `visibility: hidden`, ale z drugiej strony stanie siÄ™ zupeÅ‚nie niedostÄ™pny (tak jak dzieje siÄ™ to dla elementÃ³w schowanych za pomocÄ… `display: none`).

### I jeszcze obiecany `contain-intrinsic-size`

Jest on placeholderem wielkoÅ›ci elementÃ³w, na ktÃ³re naÅ‚oÅ¼yliÅ›my `contain: size`, w tym `content-visibility: auto`.

Gdy do elementu dodamy wspomniane wÅ‚aÅ›ciwoÅ›ci, to zacznie on siÄ™ zachowywaÄ‡ tak, jakby nie miaÅ‚ w sobie Å¼adnej zawartoÅ›ci. Dlatego gdy chcemy, aby jego wysokoÅ›Ä‡ nie wynosiÅ‚a 0 pikseli, to musimy na sztywno zdefiniowaÄ‡ jego wysokoÅ›Ä‡ i szerokoÅ›Ä‡.

> A co jeÅ›li mamy element, na przykÅ‚ad generowany z backendu, na ktÃ³rym nie jesteÅ›my w stanie ustawiÄ‡ staÅ‚ej szerokoÅ›ci i wysokoÅ›ci, bo nie wiemy ile bÄ™dÄ… wynosiÄ‡?

Wtedy pojawia siÄ™ problem, bo gdy nie ustawimy dla niego sztywnej wielkoÅ›ci, a przy tym zabierzemy z niego `contain: size` lub dojedziemy do danego elementu, na ktÃ³rym jest `content-visibility: auto`, to zaaplikuje on swojÄ… prawdziwÄ… wysokoÅ›Ä‡, wg swoich potomkÃ³w. A to doprowadzi do tego, Å¼e nasza strona bÄ™dzie po prostu skakaÄ‡, przez co stanie siÄ™ mniej przyjemna dla uÅ¼ytkownikÃ³w i zacznie gorzej wypadaÄ‡ w [metrykach](https://web.dev/cls/).

I tu na pomoc przychodzi nam wÅ‚aÅ›nie:

```css
contain-intrinsic-size: 1000px;
```

PrzypisujÄ…c tÄ™ wÅ‚aÅ›ciwoÅ›Ä‡ w pokazany wyÅ¼ej sposÃ³b, mÃ³wimy przeglÄ…darce, Å¼eby zarezerwowaÅ‚a 1000px szerokoÅ›ci i wysokoÅ›ci na dany element.

DziÄ™ki temu, gdy zostanie on juÅ¼ w peÅ‚ni zaÅ‚adowany (na przykÅ‚ad przy zjechaniu do konkretnej sekcji, na ktÃ³rej mamy `content-visibility: auto`), to struktura strony nie przesunie siÄ™ tak bardzo lub nie przesunie siÄ™ w ogÃ³le (to jest efekt, do ktÃ³rego dÄ…Å¼ymy) jeÅ›li wysokoÅ›Ä‡ elementu bÄ™dzie rÃ³wna dokÅ‚adnie 1000 pikseli.

## A czy na coÅ› jeszcze wpÅ‚ywajÄ… nasze wÅ‚aÅ›ciwoÅ›ci, poza wydajnoÅ›ciÄ…?

Tak, ale tu niestety juÅ¼ nie tak pozytywnie - na dostÄ™pnoÅ›Ä‡.

Elementy, do ktÃ³rych dodamy `content-visibility` lub `content: paint` (ktÃ³ry jest czÄ™Å›ciÄ… tego pierwszego), niestety [przestajÄ… byÄ‡ dostÄ™pne dla technologii wspomagajÄ…cych przeglÄ…danie stron internetowych](https://marcysutton.com/content-visibility-accessible-semantics), na przykÅ‚ad czytnikÃ³w ekranowych.

Dlatego musisz uwaÅ¼aÄ‡ z tym, jak korzystasz z owych wÅ‚aÅ›ciwoÅ›ci - renderowaÄ‡ za ich pomocÄ… elementy mniej istotne (na przykÅ‚ad stopkÄ™ z analogicznymi linkami, do nawigacji na gÃ³rze lub zwykÅ‚y tekst ze zdjÄ™ciami, bez nagÅ‚Ã³wkÃ³w, linkÃ³w i formularzy).

## Wszystko super, a jak ze wsparciem przeglÄ…darek?

No i przyszedÅ‚ pan maruda.

Nie no, tak serio to nie jest z tym tak najgorzej.

W dniu pisania tego artykuÅ‚u (20.02.2021), `contain` radzi sobie dobrze:

![](./contain-ciu.jpg)

Content-visibility troszkÄ™ sÅ‚abiej:

![](./content-visibility-ciu.jpg)

Natomiast moÅ¼emy liczyÄ‡ na zmienÄ™ tego stanu rzeczy, bo na przykÅ‚ad [twÃ³rcy Firefoxa, myÅ›lÄ… o pracach nad tÄ… funkcjÄ…](https://github.com/mozilla/standards-positions/issues/135). Bardzo moÅ¼liwe, Å¼e jeÅ›li czytasz te sÅ‚owa jakiÅ› czas po stworzeniu tego artykuÅ‚u, to juÅ¼ zdÄ…Å¼yÅ‚o siÄ™ w tym kontekÅ›cie poprawiÄ‡.

I to bÄ™dzie na tyle, mam nadziejÄ™, Å¼e ten artykuÅ‚ byÅ‚ dla Ciebie jak najbardziej przydatny! JeÅ›li tak, to moÅ¼esz teÅ¼ zawsze podrzuciÄ‡ ten artykuÅ‚ osobie, ktÃ³ra moÅ¼e wynieÅ›Ä‡Â z niego wartoÅ›Ä‡ âœ¨
